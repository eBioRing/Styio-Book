# 重复定义

重复定义, 它是一种自由的代价, 是开发者编码不规范给自己埋下的地雷. 如果你选择放飞自我, 在不久的将来, 你就可能会付出代价.&#x20;

#### Example 1.1

这个例子中的 Point 被重复定义了, 因此有效的是 (x, y, z) 的定义.&#x20;

```
@Point : #(x, y)

@Point : #(x, y, z)
```

#### Example 1.2

这个例子中的 Point 经过了一次重复定义, 然后被固定在了(x, y, z), 而之后对于 Point 的重复定义都会被忽略, 因此有效的是 (x, y, z) 的定义.&#x20;

```
@Point : #(x, y)

@Point := #(x, y, z)

// ignored
@Point : #(x, y)
```

有些编程语言对开发者施加极大的限制(Rust), 有些编程语言几乎没有限制(C++, Python). 但无论如何, 它们都拥有极为强大的表达能力.&#x20;

Styio 为了支持 覆盖, 重载, 重写, 在不得已的情况下, 允许覆盖之前定义过的任何资源.&#x20;

使用 `:` 定义的资源, 允许重载, 新的定义会覆盖旧的定义.

使用 `:=`  定义的资源, 不允许重载, 新的定义会被忽略. 这种错误**不会导致程序中断**.

也就是说, 在以下例子中, 对于 `Point` 的定义将永远固定在 `(x, y)`, 而不是 `(x, y, z)`.&#x20;

```
@Point := #(x, y)

// 忽略
@Point : #(x, y, z)
```

这会导致一个警告:

```
Warning: The duplicated definition has been ignored: `@Point : #(x, y, z)`
```

允许这样的写法是一个极其不负责任的功能, 所以它是一个编译器选项, 在默认情况下, 是开启的. 但是为了软件工程的编程规范, 也可以关闭.&#x20;

Styio 希望在保证 符号纯粹性 和 直觉简单性 的同时, 尽可能降低对编码规范的限制. 在几乎所有情况下, 所谓的最佳编程实践都会拒绝重复定义这样的功能. 但我认为这应该是可选的. 优秀的开发者永远有一套自己的原则, 但新手开发者追求的更多是将程序正确地运行起来. 如果一个团队中有高级开发者, 那么其应该有能力选择适合团队的编程规范, 而不是在语言的层面上进行限制. 在这一点上, 人的规则优先于编译器的规则.&#x20;
